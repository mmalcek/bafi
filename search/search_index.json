{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"BaFi Universal JSON, BSON, YAML, CSV, XML, mt940 translator to ANY format using templates Github repository - https://github.com/mmalcek/bafi Releases (Windows, MAC, Linux) - https://github.com/mmalcek/bafi/releases Key features Various input formats (json, bson, yaml, csv, xml, mt940) Flexible output formatting using text templates Support for Lua custom functions which allows very flexible data manipulation stdin/stdout support which allows get data from source -> translate -> delivery to destination. This allows easily translate data between different web services like REST to SOAP, SOAP to REST, REST to CSV, ... Merge multiple input files in various formats into single output file formated using template If you like this app you can buy me a coffe ;) How does it work? Application automaticaly parse input data into object which can be simply accessed in tamplate using dot notation where first dot represent root of object {{ . }} . For example JSON document myUser.json { \"user\": { \"name\": \"John Doe\", \"age\": 25, \"address\": { \"street\": \"Main Street\", \"city\": \"New York\", \"state\": \"NY\" }, \"favourite_colors\": [\"red\", \"green\", \"blue\"] } } Get user name: bafi.exe -i myUser.json -t '?{{.user.name}}' Use function to change all letters to uppercase: bafi.exe -i myUser.json -t '?{{upper .user.name}}' Use IF statement to compare user age to 20: bafi.exe -i myUser.json -t '?User is {{if gt (toInt .user.age) 20}}old{{else}}young{{end}}.' List favourite colors: bafi.exe -i myUser.json -t '?{{range .user.favourite_colors}}{{.}},{{end}}' Format data using template file myTemplate.tmpl and save output to myUser.txt : bafi.exe -i myUser.json -t myTemplate.tmpl -o myUser.txt {{- /* Content of myTemplate.tmpl file */ -}} User: {{.user.name}} Age: {{.user.age}} Address: {{.user.address.street}}, {{.user.address.city}} - {{.user.address.state}} {{- /* Create list of colors and remove comma at the end */ -}} {{- $colors := \"\"}}{{range .user.favourite_colors}}{{$colors = print $colors . \", \"}}{{end}} {{- $colors = print (trimSuffix $colors \", \" )}} Favourite colors: {{$colors}} note: in Powershell you must use .\\ bafi.exe e.g. .\\bafi.exe -i input.csv -t \"?{{toXML .}}\" curl.exe -s someurl.com/api/xxx | .\\bafi.exe -f json -t \"?{{toXML .}}\" More examples here const go = new Go(); WebAssembly .instantiateStreaming(fetch('js/bafi.wasm'), go.importObject) .then((result) => { go.run(result.instance)}); function getBAFI() { let input1 = document.getElementById(\"input1\").value; let input2 = document.getElementById(\"input2\").value; let format = document.getElementById(\"format\").value; var element = document.getElementById(\"bafiData\"); element.innerHTML = bafi(input1,input2,format); } Online demo (WASM) Just try it here :) { \"user\": { \"name\": \"John Doe\", \"age\": 25, \"address\": { \"street\": \"Main Street\", \"city\": \"New York\", \"state\": \"NY\" }, \"favourite_colors\": [\"red\", \"green\", \"blue\"] } } Hello {{upper .user.name}}, you are {{.user.age}} years old and live in {{.user.address.city}}, {{.user.address.state}}. Your favourite colors are: {{range .user.favourite_colors}} {{.}} {{end}} JSON XML YAML CSV Create OUTPUT Command line arguments -i input.xml Input file name. If not defined app tries read stdin If prefixed with \"?\" ( -i ?files.yaml ) app will expect yaml file with multiple files description. See example -o output.txt Output file name. If not defined result is send to stdout -t template.tmpl Template file. Alternatively you can use inline template inline template must start with ? e.g. -t \"?{{.someValue}}\" -f json Input format. Supported formats: json, bson, yaml, csv, xml, mt940 If not defined (for file input) app tries detect input format automatically by file extension -d ',' Data delimiter format CSV: Can be defined as string e.g. -d ',' or as hex value prefixed by 0x e.g. 'TAB' can be defined as -f 0x09. Default delimiter is comma ( , ) format mt940: For Multiple messages in one file (e.g. Multicash). Can be defined as string e.g. -d '$'. If delimiter is set BaFi will return array of mt940 messages -v Show current verion -? list available command line arguments bafi.exe -i testdata.xml -t template.tmpl -o output.txt More examples here Templates Bafi uses text/template . Here is a quick summary how to use. Examples are based on testdata.xml included in project note: in vscode you can use gotemplate-syntax for syntax highlighting Comments {{/* a comment */}} {{- /* a comment with white space trimmed from preceding and following text */ -}} Trim new line New line before or after text can be trimmed by adding dash {{- .TOP_LEVEL}}, {{.TOP_LEVEL -}} Accessing data Data are accessible by pipline which is represented by dot Simplest template {{.}} Get data form inner node {{.TOP_LEVEL}} Get data from XML tag. XML tags are autoprefixed by dash and accessible as index {{index .TOP_LEVEL \"-description\"}} Convert TOP_LEVEL node to JSON {{toJSON .TOP_LEVEL}} Variables You can store selected data to template variable {{$myVar := .TOP_LEVEL}} Actions Template allows to use actions , for example Iterate over lines {{range .TOP_LEVEL.DATA_LINE}}{{.val1}}{{end}} If statement {{if gt (int $val1) (int $val2)}}Value1{{else}}Value2{{end}} is greater Functions In go templates all operations are done by functions where function name is followed by operands For example: count val1+val2 {{add $val1 $val2}} count (val1+val2)/val3 {{div (add $val1 $val2) $val3}} This is called Polish notation or \"Prefix notation\" also used in another languages like Lisp The key benefit of using this notation is that order of operations is clear. For example 6/2*(1+2) - even diferent calculators may have different opinion on order of operations in this case. With Polish notation order of operations is strictly defined (from inside to outside) div 6 (mul 2 (add 1 2)) . This brings benefits with increasing number of operations especially in templates where math and non-math operations can be mixed together. For example we have json array of items numbered from 0 {\"items\": [\"item-0\",\"item-1\",\"item-2\",\"item-3\"]} We need change items numbering to start with 1 . To achieve this we have to do series of operations: 1. trim prefix \"item-\" -> 2. convert to int -> 3. add 1 -> 4. convert to string -> 5. append \"item-\" for all items in range. This can be done in one line {{ range .items }}{{ print \"item-\" (toString (add1 (toInt (trimPrefix . \"item-\")))) }} {{ end }} or alternatively (slightly shorter) print formatted string - examples here , documentation here {{ range .items }}{{ printf \"item-%d \" (add1 (toInt (trimPrefix . \"item-\"))) }}{{ end }} but BaFi also tries automaticaly cast variables so the shortest option is {{range .items}}{{print \"item-\" (add1 (trimPrefix . \"item-\"))}} {{end}} Expected result: item-1 item-2 item-3 item-4 There are 3 categories of functions Native functions text/template integrates native functions to work with data Additional functions Asside of integated functions bafi contains additional common functions Math functions add - {{add .Value1 .Value2}} add1 - {{add1 .Value1}} = Value1+1 sub - substract div - divide mod - modulo mul - multiply randInt - return random integer {{randInt .Min .Max}} add1f - \"...f\" functions parse float but provide decimal operations using shopspring decimal addf subf divf mulf round - {{round .Value1 2}} - will round to 2 decimals max - {{round .Value1 .Value2 .Value3 ...}} get Max value from range min - get Min value from range maxf minf Date functions dateFormat - {{dateFormat .Value \"oldFormat\" \"newFormat\"}} - GO time format {{dateFormat \"2021-08-26T22:14:00\" \"2006-01-02T15:04:05\" \"02.01.2006-15:04\"}} dateFormatTZ - {{dateFormatTZ .Value \"oldFormat\" \"newFormat\" \"timeZone\"}} This fuction is similar to dateFormat but applies timezone offset - Timezones {{dateFormatTZ \"2021-08-26T03:35:00.000+04:00\" \"2006-01-02T15:04:05.000-07:00\" \"02.01.2006-15:04\" \"Europe/Prague\"}} dateToInt - {{dateToInt .Value \"dateFormat\"}} - convert date to integer (unixtime, int64), usefull for comparing dates intToDate - {{intToDate .Value \"dateFormat\"}} - convert integer (unixtime, int64) to date, usefull for comparing dates now - {{now \"02.01.2006\"}} - GO format date (see notes below) String functions addSubstring - {{addSubstring $myString, \"XX\", $position}} add substring to $position in string (if $position is 1,2,3 = Adding from right, if -1,-2,-3 = Adding from left) atoi - {{atoi \"042\"}} - string to int. Result will be 42. atoi must be used especially for convert strings with leading zeroes b64enc - encode to base64 b64dec - decode from base64 b32enc - oncode to base32 b32dec - decode from base32 contains - check if string contains substring e.g. {{contains \"aaxbb\" \"xb\"}} indexOf - {{indexOf \"aaxbb\" \"xb\"}} - returns indexOf first char of substring in string isArray - {{isArray .Value1}} - check if value is array isBool - {{isBool .Value1}} - check if value is bool isInt - {{isInt .Value1}} - check if value is int isFloat64 - {{isFloat64 .Value1}} - check if value is float64 isString - {{isString .Value1}} - check if value is string isMap - {{isMap .Value1}} - check if value is map regexMatch - {{regexMatch pattern .Value1}} more about go regex replaceAll - {{replaceAll \"oldValue\" \"newValue\" .Value}} - replace all occurences of \"oldValue\" with \"newValue\" e.g. {{replaceAll \"x\" \"Z\" \"aaxbb\"}} -> \"aaZbb\" replaceAllRegex - {{replaceAllRegex \"regex\" \"newValue\" .Value}} - replace all occurences of \"regex\" with \"newValue\" e.g. {{replaceAllRegex \"[a-d]\", \"Z\" \"aaxbb\"}} -> \"ZZxZZ\" lower - to lowercase trim - remove leading and trailing whitespace trimPrefix - {{trimPrefix \"!Hello World!\" \"!\"}} - returns \"Hello World!\" trimSuffix - {{trimSuffix \"!Hello World!\" \"!\"}} - returns \"!HelloWorld\" mapJSON - convert stringified JSON to map so it can be used as object or translated to other formats (e.g. \"toXML\"). Check template.tmpl for example mustArray - {{mustArray .Value1}} - convert to array. Useful with XML where single node is not treated as array toBool - {{toBool \"true\"}} - string to bool toDecimal - {{toDecimal \"3.14159\"}} - cast to decimal (if error return 0) toDecimalString - {{toDecimalString \"3.14159\"}} - cast to decimal string (if error return \"error message\") toFloat64 - {{float64 \"3.14159\"}} - cast to float64 toInt - {{int true}} - cast to int. Result will be 1. If you need convert string with leading zeroes use \"atoi\" toInt64 - {{int64 \"42\"}} - cast to int64. Result will be 42. If you need convert string with leading zeroes use \"atoi\" toString - {{toString 42}} - int to string toJSON - convert input object to JSON toBSON - convert input object to BSON toYAML - convert input object to YAML toXML - convert input object to XML trimAll - {{trimAll \"!Hello World!\" \"!\"}} - returns \"Hello World\" upper - to uppercase uuid - generate UUID Lua custom functions You can write your own custom lua functions defined in ./lua/functions.lua file Call Lua function in template (\"sum\" - Lua function name) {{lua \"sum\" .val1 .val2}} Input is always passed as stringified JSON and should be decoded (json.decode(incomingData)) Output must be passed as string lua table array starts with 1 Lua documentation Minimal functions.lua example json = require './lua/json' function sum(incomingData) dataTable = json.decode(incomingData) return tostring(tonumber(dataTable[1]) + tonumber(dataTable[2])) end Check examples and template.tmpl and testdata.xml for advanced examples","title":"Application"},{"location":"#bafi","text":"Universal JSON, BSON, YAML, CSV, XML, mt940 translator to ANY format using templates Github repository - https://github.com/mmalcek/bafi Releases (Windows, MAC, Linux) - https://github.com/mmalcek/bafi/releases","title":"BaFi"},{"location":"#key-features","text":"Various input formats (json, bson, yaml, csv, xml, mt940) Flexible output formatting using text templates Support for Lua custom functions which allows very flexible data manipulation stdin/stdout support which allows get data from source -> translate -> delivery to destination. This allows easily translate data between different web services like REST to SOAP, SOAP to REST, REST to CSV, ... Merge multiple input files in various formats into single output file formated using template If you like this app you can buy me a coffe ;)","title":"Key features"},{"location":"#how-does-it-work","text":"Application automaticaly parse input data into object which can be simply accessed in tamplate using dot notation where first dot represent root of object {{ . }} . For example JSON document myUser.json { \"user\": { \"name\": \"John Doe\", \"age\": 25, \"address\": { \"street\": \"Main Street\", \"city\": \"New York\", \"state\": \"NY\" }, \"favourite_colors\": [\"red\", \"green\", \"blue\"] } } Get user name: bafi.exe -i myUser.json -t '?{{.user.name}}' Use function to change all letters to uppercase: bafi.exe -i myUser.json -t '?{{upper .user.name}}' Use IF statement to compare user age to 20: bafi.exe -i myUser.json -t '?User is {{if gt (toInt .user.age) 20}}old{{else}}young{{end}}.' List favourite colors: bafi.exe -i myUser.json -t '?{{range .user.favourite_colors}}{{.}},{{end}}' Format data using template file myTemplate.tmpl and save output to myUser.txt : bafi.exe -i myUser.json -t myTemplate.tmpl -o myUser.txt {{- /* Content of myTemplate.tmpl file */ -}} User: {{.user.name}} Age: {{.user.age}} Address: {{.user.address.street}}, {{.user.address.city}} - {{.user.address.state}} {{- /* Create list of colors and remove comma at the end */ -}} {{- $colors := \"\"}}{{range .user.favourite_colors}}{{$colors = print $colors . \", \"}}{{end}} {{- $colors = print (trimSuffix $colors \", \" )}} Favourite colors: {{$colors}} note: in Powershell you must use .\\ bafi.exe e.g. .\\bafi.exe -i input.csv -t \"?{{toXML .}}\" curl.exe -s someurl.com/api/xxx | .\\bafi.exe -f json -t \"?{{toXML .}}\" More examples here const go = new Go(); WebAssembly .instantiateStreaming(fetch('js/bafi.wasm'), go.importObject) .then((result) => { go.run(result.instance)}); function getBAFI() { let input1 = document.getElementById(\"input1\").value; let input2 = document.getElementById(\"input2\").value; let format = document.getElementById(\"format\").value; var element = document.getElementById(\"bafiData\"); element.innerHTML = bafi(input1,input2,format); }","title":"How does it work?"},{"location":"#online-demo-wasm","text":"Just try it here :) { \"user\": { \"name\": \"John Doe\", \"age\": 25, \"address\": { \"street\": \"Main Street\", \"city\": \"New York\", \"state\": \"NY\" }, \"favourite_colors\": [\"red\", \"green\", \"blue\"] } } Hello {{upper .user.name}}, you are {{.user.age}} years old and live in {{.user.address.city}}, {{.user.address.state}}. Your favourite colors are: {{range .user.favourite_colors}} {{.}} {{end}} JSON XML YAML CSV Create OUTPUT","title":"Online demo (WASM)"},{"location":"#command-line-arguments","text":"-i input.xml Input file name. If not defined app tries read stdin If prefixed with \"?\" ( -i ?files.yaml ) app will expect yaml file with multiple files description. See example -o output.txt Output file name. If not defined result is send to stdout -t template.tmpl Template file. Alternatively you can use inline template inline template must start with ? e.g. -t \"?{{.someValue}}\" -f json Input format. Supported formats: json, bson, yaml, csv, xml, mt940 If not defined (for file input) app tries detect input format automatically by file extension -d ',' Data delimiter format CSV: Can be defined as string e.g. -d ',' or as hex value prefixed by 0x e.g. 'TAB' can be defined as -f 0x09. Default delimiter is comma ( , ) format mt940: For Multiple messages in one file (e.g. Multicash). Can be defined as string e.g. -d '$'. If delimiter is set BaFi will return array of mt940 messages -v Show current verion -? list available command line arguments bafi.exe -i testdata.xml -t template.tmpl -o output.txt More examples here","title":"Command line arguments"},{"location":"#templates","text":"Bafi uses text/template . Here is a quick summary how to use. Examples are based on testdata.xml included in project note: in vscode you can use gotemplate-syntax for syntax highlighting","title":"Templates"},{"location":"#comments","text":"{{/* a comment */}} {{- /* a comment with white space trimmed from preceding and following text */ -}}","title":"Comments"},{"location":"#trim-new-line","text":"New line before or after text can be trimmed by adding dash {{- .TOP_LEVEL}}, {{.TOP_LEVEL -}}","title":"Trim new line"},{"location":"#accessing-data","text":"Data are accessible by pipline which is represented by dot Simplest template {{.}} Get data form inner node {{.TOP_LEVEL}} Get data from XML tag. XML tags are autoprefixed by dash and accessible as index {{index .TOP_LEVEL \"-description\"}} Convert TOP_LEVEL node to JSON {{toJSON .TOP_LEVEL}}","title":"Accessing data"},{"location":"#variables","text":"You can store selected data to template variable {{$myVar := .TOP_LEVEL}}","title":"Variables"},{"location":"#actions","text":"Template allows to use actions , for example Iterate over lines {{range .TOP_LEVEL.DATA_LINE}}{{.val1}}{{end}} If statement {{if gt (int $val1) (int $val2)}}Value1{{else}}Value2{{end}} is greater","title":"Actions"},{"location":"#functions","text":"In go templates all operations are done by functions where function name is followed by operands For example: count val1+val2 {{add $val1 $val2}} count (val1+val2)/val3 {{div (add $val1 $val2) $val3}} This is called Polish notation or \"Prefix notation\" also used in another languages like Lisp The key benefit of using this notation is that order of operations is clear. For example 6/2*(1+2) - even diferent calculators may have different opinion on order of operations in this case. With Polish notation order of operations is strictly defined (from inside to outside) div 6 (mul 2 (add 1 2)) . This brings benefits with increasing number of operations especially in templates where math and non-math operations can be mixed together. For example we have json array of items numbered from 0 {\"items\": [\"item-0\",\"item-1\",\"item-2\",\"item-3\"]} We need change items numbering to start with 1 . To achieve this we have to do series of operations: 1. trim prefix \"item-\" -> 2. convert to int -> 3. add 1 -> 4. convert to string -> 5. append \"item-\" for all items in range. This can be done in one line {{ range .items }}{{ print \"item-\" (toString (add1 (toInt (trimPrefix . \"item-\")))) }} {{ end }} or alternatively (slightly shorter) print formatted string - examples here , documentation here {{ range .items }}{{ printf \"item-%d \" (add1 (toInt (trimPrefix . \"item-\"))) }}{{ end }} but BaFi also tries automaticaly cast variables so the shortest option is {{range .items}}{{print \"item-\" (add1 (trimPrefix . \"item-\"))}} {{end}} Expected result: item-1 item-2 item-3 item-4 There are 3 categories of functions","title":"Functions"},{"location":"#native-functions","text":"text/template integrates native functions to work with data","title":"Native functions"},{"location":"#additional-functions","text":"Asside of integated functions bafi contains additional common functions","title":"Additional functions"},{"location":"#math-functions","text":"add - {{add .Value1 .Value2}} add1 - {{add1 .Value1}} = Value1+1 sub - substract div - divide mod - modulo mul - multiply randInt - return random integer {{randInt .Min .Max}} add1f - \"...f\" functions parse float but provide decimal operations using shopspring decimal addf subf divf mulf round - {{round .Value1 2}} - will round to 2 decimals max - {{round .Value1 .Value2 .Value3 ...}} get Max value from range min - get Min value from range maxf minf","title":"Math functions"},{"location":"#date-functions","text":"dateFormat - {{dateFormat .Value \"oldFormat\" \"newFormat\"}} - GO time format {{dateFormat \"2021-08-26T22:14:00\" \"2006-01-02T15:04:05\" \"02.01.2006-15:04\"}} dateFormatTZ - {{dateFormatTZ .Value \"oldFormat\" \"newFormat\" \"timeZone\"}} This fuction is similar to dateFormat but applies timezone offset - Timezones {{dateFormatTZ \"2021-08-26T03:35:00.000+04:00\" \"2006-01-02T15:04:05.000-07:00\" \"02.01.2006-15:04\" \"Europe/Prague\"}} dateToInt - {{dateToInt .Value \"dateFormat\"}} - convert date to integer (unixtime, int64), usefull for comparing dates intToDate - {{intToDate .Value \"dateFormat\"}} - convert integer (unixtime, int64) to date, usefull for comparing dates now - {{now \"02.01.2006\"}} - GO format date (see notes below)","title":"Date functions"},{"location":"#string-functions","text":"addSubstring - {{addSubstring $myString, \"XX\", $position}} add substring to $position in string (if $position is 1,2,3 = Adding from right, if -1,-2,-3 = Adding from left) atoi - {{atoi \"042\"}} - string to int. Result will be 42. atoi must be used especially for convert strings with leading zeroes b64enc - encode to base64 b64dec - decode from base64 b32enc - oncode to base32 b32dec - decode from base32 contains - check if string contains substring e.g. {{contains \"aaxbb\" \"xb\"}} indexOf - {{indexOf \"aaxbb\" \"xb\"}} - returns indexOf first char of substring in string isArray - {{isArray .Value1}} - check if value is array isBool - {{isBool .Value1}} - check if value is bool isInt - {{isInt .Value1}} - check if value is int isFloat64 - {{isFloat64 .Value1}} - check if value is float64 isString - {{isString .Value1}} - check if value is string isMap - {{isMap .Value1}} - check if value is map regexMatch - {{regexMatch pattern .Value1}} more about go regex replaceAll - {{replaceAll \"oldValue\" \"newValue\" .Value}} - replace all occurences of \"oldValue\" with \"newValue\" e.g. {{replaceAll \"x\" \"Z\" \"aaxbb\"}} -> \"aaZbb\" replaceAllRegex - {{replaceAllRegex \"regex\" \"newValue\" .Value}} - replace all occurences of \"regex\" with \"newValue\" e.g. {{replaceAllRegex \"[a-d]\", \"Z\" \"aaxbb\"}} -> \"ZZxZZ\" lower - to lowercase trim - remove leading and trailing whitespace trimPrefix - {{trimPrefix \"!Hello World!\" \"!\"}} - returns \"Hello World!\" trimSuffix - {{trimSuffix \"!Hello World!\" \"!\"}} - returns \"!HelloWorld\" mapJSON - convert stringified JSON to map so it can be used as object or translated to other formats (e.g. \"toXML\"). Check template.tmpl for example mustArray - {{mustArray .Value1}} - convert to array. Useful with XML where single node is not treated as array toBool - {{toBool \"true\"}} - string to bool toDecimal - {{toDecimal \"3.14159\"}} - cast to decimal (if error return 0) toDecimalString - {{toDecimalString \"3.14159\"}} - cast to decimal string (if error return \"error message\") toFloat64 - {{float64 \"3.14159\"}} - cast to float64 toInt - {{int true}} - cast to int. Result will be 1. If you need convert string with leading zeroes use \"atoi\" toInt64 - {{int64 \"42\"}} - cast to int64. Result will be 42. If you need convert string with leading zeroes use \"atoi\" toString - {{toString 42}} - int to string toJSON - convert input object to JSON toBSON - convert input object to BSON toYAML - convert input object to YAML toXML - convert input object to XML trimAll - {{trimAll \"!Hello World!\" \"!\"}} - returns \"Hello World\" upper - to uppercase uuid - generate UUID","title":"String functions"},{"location":"#lua-custom-functions","text":"You can write your own custom lua functions defined in ./lua/functions.lua file Call Lua function in template (\"sum\" - Lua function name) {{lua \"sum\" .val1 .val2}} Input is always passed as stringified JSON and should be decoded (json.decode(incomingData)) Output must be passed as string lua table array starts with 1 Lua documentation Minimal functions.lua example json = require './lua/json' function sum(incomingData) dataTable = json.decode(incomingData) return tostring(tonumber(dataTable[1]) + tonumber(dataTable[2])) end Check examples and template.tmpl and testdata.xml for advanced examples","title":"Lua custom functions"},{"location":"about/","text":"About BaFi What BaFi stands for BaFi is an acronym for Babel Fish from The Hitchhiker's Guide to the Galaxy Motivation This tool has been created for systems@work internal purposes. It is and always will be Open-source/ MIT license . Questions If you have any questions, please feel free to open discussion here or report an issue here .","title":"About"},{"location":"about/#about-bafi","text":"","title":"About BaFi"},{"location":"about/#what-bafi-stands-for","text":"BaFi is an acronym for Babel Fish from The Hitchhiker's Guide to the Galaxy","title":"What BaFi stands for"},{"location":"about/#motivation","text":"This tool has been created for systems@work internal purposes. It is and always will be Open-source/ MIT license .","title":"Motivation"},{"location":"about/#questions","text":"If you have any questions, please feel free to open discussion here or report an issue here .","title":"Questions"},{"location":"examples/","text":"Examples Command line note: in Powershell you must use .\\ bafi.exe e.g. .\\bafi.exe -i input.csv -t \"?{{toXML .}}\" curl.exe -s someurl.com/api/xxx | .\\bafi.exe -f json -t \"?{{toXML .}}\" Basic Get data from testdata.xml -> process using template.tmpl -> save output as output.txt bafi.exe -i testdata.xml -t template.tmpl -o output.txt Inline template Get data from testdata.xml -> process using inline template -> save output as output.json bafi.exe -i testdata.xml -o output.json -t \"?{{toJSON .}}\" note: BaFi inline template must start with ? e.g. \"?{{toJSON .}}\" How to format inline templates Stdin/REST Get data from REST api -> convert to XML -> output to Stdout. curl.exe -s https://api.predic8.de/shop/customers/ | bafi.exe -f json -t \"?{{toXML .}}\" More info about curl here but you can of course use any tool with stdout Append output file Redirect stdout to file and append ( > = replace, >> = apppend ) bafi.exe -i testdata.xml -t template.tmpl >> output.txt Template Examples are based on testdata.tmpl included in project XML to CSV command bafi.exe -i testdata.xml -t myTemplate.tmpl -o output.csv myTemplate.tmpl Employee,Date,val1,val2,val3,SUM,LuaMultiply,linkedText {{- range .TOP_LEVEL.DATA_LINE}} {{index .Employee \"-ID\"}}, {{- dateFormat .Trans_Date \"2006-01-02\" \"02.01.2006\"}}, {{- .val1}},{{.val2}},{{.val3}}, {{- add .val1 .val2}}, {{- lua \"mul\" .val1 .val2}},\"{{index .Linked_Text \"-VALUE\"}}\" {{- end}} JSON to CSV command curl.exe -s https://api.predic8.de/shop/customers/ | bafi.exe -f json -t myTemplate.tmpl -o output.html myTemplate.tmpl name,surname {{- range .customers}} \"{{.firstname}}\",\"{{.lastname}}\" {{- end}} JSON to HTML command curl.exe -s https://api.predic8.de/shop/customers/ | bafi.exe -f json -t myTemplate.tmpl -o output.html myTemplate.tmpl <html> <body> <table> <tr><th>Name</th><th>Surname</th></tr> {{- range .customers}} <tr><td>{{.firstname}}</td><td>{{.lastname}}</td></tr> {{- end }} </table> </body> </html> <style> table, th, td { border: 1px solid black; width: 400px; } </style> JSON to custom XML command curl.exe -s https://api.predic8.de/shop/customers/ | bafi.exe -f json -t myTemplate.tmpl -o output.xml myTemplate.tmpl <?xml version=\"1.0\" encoding=\"utf-8\"?> <MY_DATA> {{- range .customers}} <CUSTOMMER> <NAME>{{.firstname}}</NAME> <SURNAME>{{.lastname}}</SURNAME> </CUSTOMMER> {{- end }} </MY_DATA> XML to custom JSON command bafi.exe -i testdata.xml -t myTemplate.tmpl -o output.json myTemplate.tmpl {{- $new := \"{\\\"employees\\\": [\" }} {{- range .TOP_LEVEL.DATA_LINE}} {{- $new = print $new \"{\\\"employeeID\\\":\\\"\" (index .Employee \"-ID\") \"\\\", \\\"val1\\\":\" .val1 \"},\" }} {{- end}} {{- /* Trim trailing comma, alternatively you can remove last char by \"(slice $new 0 (sub (len $new) 1))\" */}} {{- $new = print (trimSuffix $new \",\" ) \"]}\"}} {{ $new}} JSON in $new variable can be mapped to struct and autoformatted to other formats like: Transform $new to YAML {{toYAML (mapJSON $new) -}} Transform $new to XML {{toXML (mapJSON $new) -}} CSV to text command bafi.exe -i users.csv -t myTemplate.tmpl -o output.txt users.csv name,surname John,\"Jack Doe\" myTemplate.tmpl Users: {{- range .}} Name: {{.name}}, Surname: {{.surname}} {{- end}} note: CSV file must be RFC4180 compliant, file must have header line and separator must be comma ( , ) . Or you can use command line argument -d ( e.g. -d ';' or -d 0x09 ) to define separator(delimiter). mt940 to CSV mt940 returns simple struct (Header,Fields,[]Transactions) of strings and additional parsing needs to be done in template. This allows full flexibility on data processing Identifiers are prefixed by \"F_\" (e.g. :20: = .Fields.F_20 ) if parameter -d (delimiter -d \"$\") is defined for files with multiple messages (e.g. - Multicash), app returns array of mt940 messages. Delimiter is automaticaly enclosed by new lines \"\\r\\n\\$\\r\\n\". Note: This is actually good place to use integrated LUA interpreter where you can create your own set of custom functions to parse data and easily reuse them in templates. command bafi.exe -i message.sta -t myTemplate.tmpl -o output.csv myTemplate.tmpl Reference, balance, VS {{- $F20 := .Fields.F_20 }}{{ $F60F := .Fields.F_60F }} {{range .Transactions }} {{- $vsS := add (indexOf .F_86 \"?21\") 3 }} {{- $vsE := add $vsS 17 -}} {{- $F20}}, {{$F60F}}, {{slice .F_86 $vsS $vsE}} {{ end }} Any SQL to XML Bafi can be used in combination with very interesting tool USQL https://github.com/xo/usql . USQL allows query almost any SQL like database (MSSQL,MySQL,postgres, ...) and get result in various formats. In this example we use -J for JSON. Output can be further processed by BaFi and templates usql.exe mssql://user:password@server/instance/database -c \"SELECT * FROM USERS\" -J -q | bafi.exe -f json -t \"?{{toXML .}}\" MongoDump to CSV command bafi.exe -i users.bson -t myTemplate.tmpl -o output.html myTemplate.tmpl name,surname {{- range .}} \"{{.firstname}}\",\"{{.lastname}}\" {{- end}} Dashes in key names If key name contains dashes ( - ) bafi will fail with error \"bad character U+002D '-'\" for example: {{.my-key.subkey}} This is known limitation of go templates which can be solved by workaround {{index . \"my-key\" \"subkey\"}} Input autoformat to XXX Input data can be easily fomated to oher formats by functions toXML,toJSON,toBSON,toYAML . In this case its not necesarry add template file because it's as easy as curl.exe -s https://api.predic8.de/shop/customers/ | bafi.exe -f json -t \"?{{toXML .}}\" -o output.xml curl.exe -s https://api.predic8.de/shop/customers/ | bafi.exe -f json -t \"?{{toJSON .}}\" -o output.json curl.exe -s https://api.predic8.de/shop/customers/ | bafi.exe -f json -t \"?{{toBSON .}}\" -o output.bson curl.exe -s https://api.predic8.de/shop/customers/ | bafi.exe -f json -t \"?{{toYAML .}}\" -o output.yml Multiple input files Bafi can read multiple input files and merge them into one output file. This will require aditional file with files description. Description file must be in YAML format as described below and prefixed by question mark \"?\" for examle bafi.exe -i ?files.yaml Example: batch file which gets the data from multiple sources myFiles.bat curl -s https://www.ecb.europa.eu/stats/eurofxref/eurofxref-daily.xml > ecbRates.xml curl -s https://goweather.herokuapp.com/weather/prague > pragueWeather.json Files description myFiles.yaml - file: ./ecbRates.xml # file path format: xml # File format label: RATES # Label which will be used in the template {{ .RATES }} - file: ./pragueWeather.json format: json label: WEATHER Template file myTemplate.tmpl which will generate simple HTML page with data <html> <body> <h3> Weather in Prague </h3> <h4> Temperatre: {{.WEATHER.temperature}} </h4> <h4> Wind: {{.WEATHER.wind}} </h4> <h3> ECB Exchange rates from: {{dateFormat (index .RATES.Envelope.Cube.Cube \"-time\") \"2006-01-02\" \"02.01.2006\" }}</h3> <table> <tr><th>currency</th><th>rate</th> {{- range .RATES.Envelope.Cube.Cube.Cube }} <tr><td>{{index . \"-currency\" }}</td><td>{{index . \"-rate\" }}</td> {{- end}} </table> <body> </html> <style> table, th, td { border: 1px solid black; width: 400px; } </style> Finally run bafi bafi.exe -t myTemplate.tmpl -i ?myFiles.yaml -o output.html","title":"Examples"},{"location":"examples/#examples","text":"","title":"Examples"},{"location":"examples/#command-line","text":"note: in Powershell you must use .\\ bafi.exe e.g. .\\bafi.exe -i input.csv -t \"?{{toXML .}}\" curl.exe -s someurl.com/api/xxx | .\\bafi.exe -f json -t \"?{{toXML .}}\"","title":"Command line"},{"location":"examples/#basic","text":"Get data from testdata.xml -> process using template.tmpl -> save output as output.txt bafi.exe -i testdata.xml -t template.tmpl -o output.txt","title":"Basic"},{"location":"examples/#inline-template","text":"Get data from testdata.xml -> process using inline template -> save output as output.json bafi.exe -i testdata.xml -o output.json -t \"?{{toJSON .}}\" note: BaFi inline template must start with ? e.g. \"?{{toJSON .}}\" How to format inline templates","title":"Inline template"},{"location":"examples/#stdinrest","text":"Get data from REST api -> convert to XML -> output to Stdout. curl.exe -s https://api.predic8.de/shop/customers/ | bafi.exe -f json -t \"?{{toXML .}}\" More info about curl here but you can of course use any tool with stdout","title":"Stdin/REST"},{"location":"examples/#append-output-file","text":"Redirect stdout to file and append ( > = replace, >> = apppend ) bafi.exe -i testdata.xml -t template.tmpl >> output.txt","title":"Append output file"},{"location":"examples/#template","text":"Examples are based on testdata.tmpl included in project","title":"Template"},{"location":"examples/#xml-to-csv","text":"command bafi.exe -i testdata.xml -t myTemplate.tmpl -o output.csv myTemplate.tmpl Employee,Date,val1,val2,val3,SUM,LuaMultiply,linkedText {{- range .TOP_LEVEL.DATA_LINE}} {{index .Employee \"-ID\"}}, {{- dateFormat .Trans_Date \"2006-01-02\" \"02.01.2006\"}}, {{- .val1}},{{.val2}},{{.val3}}, {{- add .val1 .val2}}, {{- lua \"mul\" .val1 .val2}},\"{{index .Linked_Text \"-VALUE\"}}\" {{- end}}","title":"XML to CSV"},{"location":"examples/#json-to-csv","text":"command curl.exe -s https://api.predic8.de/shop/customers/ | bafi.exe -f json -t myTemplate.tmpl -o output.html myTemplate.tmpl name,surname {{- range .customers}} \"{{.firstname}}\",\"{{.lastname}}\" {{- end}}","title":"JSON to CSV"},{"location":"examples/#json-to-html","text":"command curl.exe -s https://api.predic8.de/shop/customers/ | bafi.exe -f json -t myTemplate.tmpl -o output.html myTemplate.tmpl <html> <body> <table> <tr><th>Name</th><th>Surname</th></tr> {{- range .customers}} <tr><td>{{.firstname}}</td><td>{{.lastname}}</td></tr> {{- end }} </table> </body> </html> <style> table, th, td { border: 1px solid black; width: 400px; } </style>","title":"JSON to HTML"},{"location":"examples/#json-to-custom-xml","text":"command curl.exe -s https://api.predic8.de/shop/customers/ | bafi.exe -f json -t myTemplate.tmpl -o output.xml myTemplate.tmpl <?xml version=\"1.0\" encoding=\"utf-8\"?> <MY_DATA> {{- range .customers}} <CUSTOMMER> <NAME>{{.firstname}}</NAME> <SURNAME>{{.lastname}}</SURNAME> </CUSTOMMER> {{- end }} </MY_DATA>","title":"JSON to custom XML"},{"location":"examples/#xml-to-custom-json","text":"command bafi.exe -i testdata.xml -t myTemplate.tmpl -o output.json myTemplate.tmpl {{- $new := \"{\\\"employees\\\": [\" }} {{- range .TOP_LEVEL.DATA_LINE}} {{- $new = print $new \"{\\\"employeeID\\\":\\\"\" (index .Employee \"-ID\") \"\\\", \\\"val1\\\":\" .val1 \"},\" }} {{- end}} {{- /* Trim trailing comma, alternatively you can remove last char by \"(slice $new 0 (sub (len $new) 1))\" */}} {{- $new = print (trimSuffix $new \",\" ) \"]}\"}} {{ $new}} JSON in $new variable can be mapped to struct and autoformatted to other formats like: Transform $new to YAML {{toYAML (mapJSON $new) -}} Transform $new to XML {{toXML (mapJSON $new) -}}","title":"XML to custom JSON"},{"location":"examples/#csv-to-text","text":"command bafi.exe -i users.csv -t myTemplate.tmpl -o output.txt users.csv name,surname John,\"Jack Doe\" myTemplate.tmpl Users: {{- range .}} Name: {{.name}}, Surname: {{.surname}} {{- end}} note: CSV file must be RFC4180 compliant, file must have header line and separator must be comma ( , ) . Or you can use command line argument -d ( e.g. -d ';' or -d 0x09 ) to define separator(delimiter).","title":"CSV to text"},{"location":"examples/#mt940-to-csv","text":"mt940 returns simple struct (Header,Fields,[]Transactions) of strings and additional parsing needs to be done in template. This allows full flexibility on data processing Identifiers are prefixed by \"F_\" (e.g. :20: = .Fields.F_20 ) if parameter -d (delimiter -d \"$\") is defined for files with multiple messages (e.g. - Multicash), app returns array of mt940 messages. Delimiter is automaticaly enclosed by new lines \"\\r\\n\\$\\r\\n\". Note: This is actually good place to use integrated LUA interpreter where you can create your own set of custom functions to parse data and easily reuse them in templates. command bafi.exe -i message.sta -t myTemplate.tmpl -o output.csv myTemplate.tmpl Reference, balance, VS {{- $F20 := .Fields.F_20 }}{{ $F60F := .Fields.F_60F }} {{range .Transactions }} {{- $vsS := add (indexOf .F_86 \"?21\") 3 }} {{- $vsE := add $vsS 17 -}} {{- $F20}}, {{$F60F}}, {{slice .F_86 $vsS $vsE}} {{ end }}","title":"mt940 to CSV"},{"location":"examples/#any-sql-to-xml","text":"Bafi can be used in combination with very interesting tool USQL https://github.com/xo/usql . USQL allows query almost any SQL like database (MSSQL,MySQL,postgres, ...) and get result in various formats. In this example we use -J for JSON. Output can be further processed by BaFi and templates usql.exe mssql://user:password@server/instance/database -c \"SELECT * FROM USERS\" -J -q | bafi.exe -f json -t \"?{{toXML .}}\"","title":"Any SQL to XML"},{"location":"examples/#mongodump-to-csv","text":"command bafi.exe -i users.bson -t myTemplate.tmpl -o output.html myTemplate.tmpl name,surname {{- range .}} \"{{.firstname}}\",\"{{.lastname}}\" {{- end}}","title":"MongoDump to CSV"},{"location":"examples/#dashes-in-key-names","text":"If key name contains dashes ( - ) bafi will fail with error \"bad character U+002D '-'\" for example: {{.my-key.subkey}} This is known limitation of go templates which can be solved by workaround {{index . \"my-key\" \"subkey\"}}","title":"Dashes in key names"},{"location":"examples/#input-autoformat-to-xxx","text":"Input data can be easily fomated to oher formats by functions toXML,toJSON,toBSON,toYAML . In this case its not necesarry add template file because it's as easy as curl.exe -s https://api.predic8.de/shop/customers/ | bafi.exe -f json -t \"?{{toXML .}}\" -o output.xml curl.exe -s https://api.predic8.de/shop/customers/ | bafi.exe -f json -t \"?{{toJSON .}}\" -o output.json curl.exe -s https://api.predic8.de/shop/customers/ | bafi.exe -f json -t \"?{{toBSON .}}\" -o output.bson curl.exe -s https://api.predic8.de/shop/customers/ | bafi.exe -f json -t \"?{{toYAML .}}\" -o output.yml","title":"Input autoformat to XXX"},{"location":"examples/#multiple-input-files","text":"Bafi can read multiple input files and merge them into one output file. This will require aditional file with files description. Description file must be in YAML format as described below and prefixed by question mark \"?\" for examle bafi.exe -i ?files.yaml Example: batch file which gets the data from multiple sources myFiles.bat curl -s https://www.ecb.europa.eu/stats/eurofxref/eurofxref-daily.xml > ecbRates.xml curl -s https://goweather.herokuapp.com/weather/prague > pragueWeather.json Files description myFiles.yaml - file: ./ecbRates.xml # file path format: xml # File format label: RATES # Label which will be used in the template {{ .RATES }} - file: ./pragueWeather.json format: json label: WEATHER Template file myTemplate.tmpl which will generate simple HTML page with data <html> <body> <h3> Weather in Prague </h3> <h4> Temperatre: {{.WEATHER.temperature}} </h4> <h4> Wind: {{.WEATHER.wind}} </h4> <h3> ECB Exchange rates from: {{dateFormat (index .RATES.Envelope.Cube.Cube \"-time\") \"2006-01-02\" \"02.01.2006\" }}</h3> <table> <tr><th>currency</th><th>rate</th> {{- range .RATES.Envelope.Cube.Cube.Cube }} <tr><td>{{index . \"-currency\" }}</td><td>{{index . \"-rate\" }}</td> {{- end}} </table> <body> </html> <style> table, th, td { border: 1px solid black; width: 400px; } </style> Finally run bafi bafi.exe -t myTemplate.tmpl -i ?myFiles.yaml -o output.html","title":"Multiple input files"}]}